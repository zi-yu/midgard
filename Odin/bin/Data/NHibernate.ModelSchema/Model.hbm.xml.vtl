##
## Midgard NHibernate XML Schema Generator
##
############################################
##
## Variables
##
#set( $idSuffix = "ID" )
#set( $dll = ".dll" )
#set( $tableSeparator = "_" )
#set( $subclass = "subclass" )## or "joined-subclass"
##
############################################
<?xml version="1.0" encoding="utf-8" ?>
<!-- 
	WARNING: Generated File!
	*************************************************************
	Generated by Midgard`s `$pluginName` plugin
	*************************************************************
	From the `$entities.Count` entities in the Model, the following were mapped:
#foreach( $entity in $entities ) 
#if( $entity.Persistable )
		* $entity.Name
#end
#end
-->
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.0" schema="$schema">
#foreach( $entity in $entities )#if( $entity.Persistable)

	<!-- 
		$entity.Name Entity 
		RootEntity		: $entity.RootEntity
		IsBaseRoot		: $entity.IsBaseRoot
		AccessInterface	: $entity.AccessInterface
#if( $entity.HasParent)
		Parent		: $entity.Parent.Name 
#end
	-->
#if( $entity.RootEntity )
	<class		name="$namespace.$entity.AccessInterface, $namespace" 
				table="$projectName$tableSeparator$entity.Name" 
				discriminator-value="$discriminator.Generate($entity.Name)">
#else
	<$subclass	name="$namespace.$entity.AccessInterface, $namespace" 
				extends="$namespace.$entity.Parent.AccessInterface, $namespace"
				discriminator-value="$discriminator.Generate($entity.Name)">			
#end
#foreach( $field in $entity.Fields )
#set( $fieldType = $field.Type.AccessInterface )
#if( $field.IsPrimaryKey )
		<id name="$field.PropertyName" type="$hTypes.Get($fieldType)" column="$entity.Name$idSuffix">
			<generator class="native" />
		</id>
#if( $entity.IsBaseRoot )
		<discriminator column="Discriminator" type="Int32" />
#end
#elseif( $field.Type.IsIntrinsic )
		<property name="$field.PropertyName" column="$field.PropertyName" type="$hTypes.Get($fieldType)" $length.GetLength($field) />
#elseif( $field.Mult.ToString() == "OneToOne" )
		<one-to-one name="$field.PropertyName" class="$namespace.$field.Type.AccessInterface, $namespace" />
#elseif( $field.Mult.ToString() == "OneToMany" )
		<bag name="$field.PropertyName" inverse="true" lazy="$field.Lazy.ToString().ToLower()">
			<key column="$entity.Name$idSuffix" />
			<one-to-many class="$namespace.$field.Type.AccessInterface, $namespace" />
		</bag>
#elseif( $field.Mult.ToString() == "ManyToOne" )
		<many-to-one name="$field.PropertyName" column="$field.Type.Name$idSuffix" not-null="$field.IsRequired.ToString().ToLower()" />
#elseif( $field.Mult.ToString() == "ManyToMany" )
		<bag name="$field.PropertyName" inverse="$root.CheckInverse($field.Type.Name,$entity.Name )" lazy="$field.Lazy.ToString().ToLower()" table="$projectName$tableSeparator$root.InverseKey($field.Type.Name,$entity.Name )">
			<key column="$entity.Name$idSuffix" />
			<many-to-many class="$namespace.$field.Type.AccessInterface, $namespace">
				<column name="$field.Type.AccessInterface$idSuffix" />
			</many-to-many>
		</bag>
#else
		<!--
			ERROR 
			Don"t know how to handle `$field.Name` of type `$field.Type.Name` 
				* Multiplicity: `$field.Mult`
		-->
#end
#end
#if( $entity.RootEntity )
	</class>
#else
	</$subclass>
#end
#end#end
</hibernate-mapping>
